import{_ as a,c as e,o as s,a1 as n}from"./chunks/framework.BwTyoF0R.js";const g=JSON.parse('{"title":"Scripting","description":"","frontmatter":{"outline":true,"languages":"js"},"headers":[],"relativePath":"scripting.md","filePath":"scripting.md"}'),t={name:"scripting.md"},i=n(`<h1 id="scripting" tabindex="-1">Scripting <a class="header-anchor" href="#scripting" aria-label="Permalink to &quot;Scripting&quot;">​</a></h1><p>Scripts in hackmud are JavaScript (es6 strict mode) files consisting of a single function which is passed two parameters by the game, <code>context</code> and <code>args</code></p><h2 id="context" tabindex="-1">context <a class="header-anchor" href="#context" aria-label="Permalink to &quot;context&quot;">​</a></h2><p>This is a context the script is run from, i.e. if a user called noob ran your script, then any command executed from context will be treated as executed by the noob user, just like he/she would write them in their command line. Context has the following subkeys:</p><ul><li><code>caller</code>: The name of the user who is calling the script (i.e. n00b)</li><li><code>this_script</code>: The name of this script</li><li><code>calling_script</code>: The name of the script that directly called this script, or null if called on the command line or as a scriptor</li><li><code>is_scriptor</code>: true if the script is being run as a scriptor, otherwise falsey (not present currently, but I wouldn’t rely on that)</li><li><code>is_brain</code>: true if the script is being run via a bot brain</li><li><code>cols</code>: the number of columns in the caller’s terminal, if reported by the client</li><li><code>rows</code>: the number of rows in the caller’s terminal, if reported by the client</li></ul><h2 id="args" tabindex="-1">args <a class="header-anchor" href="#args" aria-label="Permalink to &quot;args&quot;">​</a></h2><p>This is a dictionary containing all the arguments a user passed to your script. If the script was called without any arguments (i.e. foo.bar), args will be null (if called on the command line) or undefined (if called as a scriptor or subscript). If called with empty arguments (i.e. foo.bar{}), args will be an empty JS object.</p><p>Both <code>context</code> and <code>args</code> can be shortened to save character count, but for now we&#39;ll leave them along for readability.</p><h2 id="first-example" tabindex="-1">first example <a class="header-anchor" href="#first-example" aria-label="Permalink to &quot;first example&quot;">​</a></h2><p>Let&#39;s start off looking at an example script from @soron</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>function (context, args) {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // if there are no arguments (args) or args.target is empty, return (exit) with an error message</span></span>
<span class="line"><span>	if (!args || !args.target) {</span></span>
<span class="line"><span>		return {</span></span>
<span class="line"><span>			ok: false,</span></span>
<span class="line"><span>			msg: &quot;Call me with {target:#s.some.script} as the arguments (for &#39;some.script&#39; that exists, such as accts.balance)&quot;</span></span>
<span class="line"><span>		}</span></span>
<span class="line"><span>	}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // we&#39;ve confirmed args.target is not empty, so we&#39;ll create a variable called target to make it easier to reference</span></span>
<span class="line"><span></span></span>
<span class="line"><span>	let target = args.target;</span></span>
<span class="line"><span>	</span></span>
<span class="line"><span>    // scripts.get_level returns a number inside scripts, or a string like &#39;FULLSEC&#39; or &#39;MIDSEC&#39; on command line</span></span>
<span class="line"><span>	let sec_level = #fs.scripts.get_level({name:target.name});</span></span>
<span class="line"><span>	</span></span>
<span class="line"><span>    // hackmud provides a set of functions to start you off in your scripting journey, there is no harm using these, but many players</span></span>
<span class="line"><span>    // will inevitably replace with their own functions</span></span>
<span class="line"><span>	let l = #fs.scripts.lib();</span></span>
<span class="line"><span>	</span></span>
<span class="line"><span>	// is it less than FULLSEC? if so, warn the user</span></span>
<span class="line"><span>	if (sec_level &lt; 4 &amp;&amp; !args.override) {</span></span>
<span class="line"><span>		let sec_level_name = l.security_level_names[sec_level];</span></span>
<span class="line"><span>		return {</span></span>
<span class="line"><span>			ok: false,</span></span>
<span class="line"><span>			msg: &quot;The script you have passed is &quot; + sec_level_name + &quot;. Are you sure you want to continue? If so, pass override:true&quot;</span></span>
<span class="line"><span>		};</span></span>
<span class="line"><span>	}</span></span>
<span class="line"><span>	</span></span>
<span class="line"><span>	let result = target.call(args.passthru);</span></span>
<span class="line"><span>	</span></span>
<span class="line"><span>	return {</span></span>
<span class="line"><span>		ok: true,</span></span>
<span class="line"><span>		msg: &quot;Target called. See &#39;debug&#39; below to inspect the output.&quot;,</span></span>
<span class="line"><span>		debug: result,</span></span>
<span class="line"><span>	}</span></span>
<span class="line"><span>}</span></span></code></pre></div><h2 id="creating-uploading-and-deleting-scripts" tabindex="-1">creating, uploading and deleting scripts <a class="header-anchor" href="#creating-uploading-and-deleting-scripts" aria-label="Permalink to &quot;creating, uploading and deleting scripts&quot;">​</a></h2><p>In order to create a script, for example called <code>cyberdeck</code>, you can run the following command in the CLI:</p><p><code>#edit cyberdeck</code></p><p>Once you&#39;re ready to upload it, you can enter:</p><p><code>#up cyberdeck</code></p><p>and you will be able to run it from the CLI by typing <code>cyberdeck</code> with or without any arguments you&#39;ve added. If you want to make a script public, you would use the switch <code>-public</code>, e.g.</p><p><code>#up cyberdeck -public</code></p><p>Conversely if you want to make a public script private again, you&#39;d use <code>-private</code> instead. The switch <code>-shift</code> may also be required if you add any script calls that are higher or lower than the first time you uploaded your script:</p><p><code>#up cyberdeck -shift</code></p><p>To delete a script you use the <code>#up</code> command with an optional switch <code>-delete</code>, e.g.</p><p><code>#up cyberdeck -delete</code></p><p>This will remove it (without confirmation) from HackMUD, but won&#39;t delete your local copy.</p><h2 id="scriptors" tabindex="-1">scriptors <a class="header-anchor" href="#scriptors" aria-label="Permalink to &quot;scriptors&quot;">​</a></h2><p>Scriptors are one of the HackMUD specific features. They allow you to call an in-game script from your script. That allows you to parameterise your script’s behavior. The scriptor syntax is as follows:</p><p><code>#s.a_user.a_command</code></p><p>The above can be then passed to your script as an argument, like the following (assuming you #up-ped the script above as <code>cyberdeck</code>):</p><p><code>cyberdeck { target:#s.a_user.a_command }</code></p><p>To call a command the scriptor points to, inside your script, there’s a <em>scriptor-specific</em> method which optionally accepts your arguments that will be passed to the called command:</p><p><code>args.target.call({ /* optional arguments for the called scriptor */ })</code></p><h2 id="autocomplete" tabindex="-1">autocomplete <a class="header-anchor" href="#autocomplete" aria-label="Permalink to &quot;autocomplete&quot;">​</a></h2><p>To add autocomplete <code>args</code> to your script, on the first line, after the function boilerplate, add a comment with a list of <code>keys</code> and <code>values</code>, like this:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>function</span></span>
<span class="line"><span>(context,args) { // arg1:val1, arg2:val2, arg3:#s.an.example, any_name:”example”</span></span>
<span class="line"><span>    ...</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>After <code>#up</code>-ing the script, you might need to run scripts.user to update your autocomplete, and then it should work.</p><h2 id="let-vs-var" tabindex="-1"><code>let</code> vs <code>var</code> <a class="header-anchor" href="#let-vs-var" aria-label="Permalink to &quot;\`let\` vs \`var\`&quot;">​</a></h2><p>When you&#39;re new to coding in JavaScript, you&#39;ll encounter two primary ways to declare variables: var and let. While both can be used to declare variables, let is generally preferred over var for several important reasons:</p><h3 id="_1-block-scope-vs-function-scope" tabindex="-1">1. Block Scope vs. Function Scope <a class="header-anchor" href="#_1-block-scope-vs-function-scope" aria-label="Permalink to &quot;1. Block Scope vs. Function Scope&quot;">​</a></h3><p><code>var</code>: Variables declared with var have function scope. This means they are accessible throughout the entire function they are declared in, regardless of where in the function the declaration happens.</p><p><code>let</code>: Variables declared with let have block scope. This means they are only accessible within the block (i.e., within the {} braces) in which they are declared.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>if (true) {</span></span>
<span class="line"><span>    var varVariable = &quot;I am a var variable&quot;;</span></span>
<span class="line"><span>    let letVariable = &quot;I am a let variable&quot;;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>console.log(varVariable); // Outputs: &quot;I am a var variable&quot;</span></span>
<span class="line"><span>console.log(letVariable); // ReferenceError: letVariable is not defined</span></span></code></pre></div><blockquote><p>The varVariable is accessible outside the if block because var has function scope. The letVariable is not accessible outside the block because let has block scope.</p></blockquote><h3 id="_2-hoisting-behavior" tabindex="-1">2. Hoisting Behavior <a class="header-anchor" href="#_2-hoisting-behavior" aria-label="Permalink to &quot;2. Hoisting Behavior&quot;">​</a></h3><p><code>var</code>: Variables declared with var are hoisted to the top of their scope. This means you can use the variable before its declaration, but it will be undefined until the declaration is encountered.</p><p><code>let</code>: Variables declared with let are also hoisted, but they are not initialized. They remain in a &quot;temporal dead zone&quot; from the start of the block until the declaration is encountered. Using the variable before its declaration results in a ReferenceError.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>console.log(varVariable); // Outputs: undefined</span></span>
<span class="line"><span>var varVariable = &quot;I am a var variable&quot;;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>console.log(letVariable); // ReferenceError: Cannot access &#39;letVariable&#39; before initialization</span></span>
<span class="line"><span>let letVariable = &quot;I am a let variable&quot;;</span></span></code></pre></div><blockquote><p>With var, the variable is hoisted and initialized with undefined. With let, accessing the variable before its declaration results in an error.</p></blockquote><h3 id="_3-accidental-globals" tabindex="-1">3. Accidental Globals <a class="header-anchor" href="#_3-accidental-globals" aria-label="Permalink to &quot;3. Accidental Globals&quot;">​</a></h3><p><code>var</code>: Declaring a variable with var inside a function but without actually using var or any other keyword (such as let or const) will create a global variable, which can lead to bugs and unintended behavior.</p><p><code>let</code>: Using let avoids this issue because it enforces block scope, and forgetting the keyword results in a ReferenceError.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>function foo() {</span></span>
<span class="line"><span>    varVariable = &quot;I am a global var variable&quot;;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>foo();</span></span>
<span class="line"><span>console.log(varVariable); // Outputs: &quot;I am a global var variable&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>function bar() {</span></span>
<span class="line"><span>    letVariable = &quot;I am trying to be a let variable&quot;; // ReferenceError: letVariable is not defined</span></span>
<span class="line"><span>}</span></span></code></pre></div><blockquote><p>In the foo function, varVariable becomes a global variable because it is not declared with var. In the bar function, trying to assign a value to letVariable without declaring it with let or const results in an error.</p></blockquote>`,51),o=[i];function l(r,c,p,d,u,h){return s(),e("div",null,o)}const m=a(t,[["render",l]]);export{g as __pageData,m as default};
